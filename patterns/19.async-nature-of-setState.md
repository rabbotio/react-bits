# Async Nature ของ setState()
สำหรับ Async nature ของ setState()

## สาระสำคัญ:
React batches จะ update และ flush ใหม่ในทุกๆ frame (เพื่อ optimize ความเร็ว) 
แต่ในบางครั้ง React ก็ไม่ได้ควบคุมการ batching ทำให้การ update อาจจะเกิดขึ้นแบบ synchronous ก็ได้
เช่น eventListeners, Ajax, setTimeout และ Web APIs ที่คล้ายๆ กัน

### แนวคิดหลัก
setState() ไม่ได้เปลี่ยนแปลงค่า this.state ทันที แต่จะสร้าง pending state transition ไว้ก่อน ถ้าเราเรียก this.state หลัง setState ทันทีก็จะได้ค่าเดิม นั่นคือ setState ไม่ได้ทำงานแบบ synchronous และบางทีก็จะโดน batch เพื่อ optimize ความเร็ว อีกตะหาก

ลองรัน code ข้างล่างดู แล้วคุณจะสังเกตเห็นว่า:

state ของก่อน และหลังทำเหตุการณ์ต่างๆ (ไม่ว่าจะ addEventListener, setTimeout หรือ AJAX call) จะแตกต่างกัน แล้วพอทำ setState method เสร็จ render ก็จะถูกเรียกใหม่ทันที แต่ทำไมเป็นแบบนั้นล่ะ? ก็จะเห็นว่าตัว React มันจะไม่เข้าใจ และจะไม่ไปควบคุม code ที่อยู่ภายนอก library ของตัวเอง ยกตัวอย่างเช่น code ส่วนที่เรียก Timeout หรือ AJAX จะทำงานอยู่นอก context ของ React

อ้าว! แล้วทำไม React ถึงได้ update state แบบ synchronous ในกรณีนี้ล่ะ? คำตอบก็คือมันพยายามจะปกป้องตัวเองให้มากที่สุด 
การที่มันไปควบคุมไม่ได้ ก็แปลว่ามันไม่สามารถจะ optimize ความเร็วอะไรได้เลย ดังนั้นมันจะดีกว่า ถ้าเรา update state เดี๋ยวนั้นเลย เพื่อให้แน่ใจได้ว่าเราจะได้ข้อมูลที่ล่าสุดมาจริงๆ 

```javascript
class TestComponent extends React.Component {
  getInitialState() {
    return {
      dollars: 10
    };
  }

  componentDidMount() {
    // เพิ่ม custom event ผ่าน `addEventListener`
    //
    // event ของ React มีส่วนที่ support `mouseleave` ผ่านทาง `onMouseLeave` prop
    //
    // แต่ว่าเราจะไม่เพิ่ม event แบบ 'React way' เพราะมันจะส่งผลกับวิธีการเปลี่ยนแปลง state
    //
    // check events list ได้ที่นี่ - https://facebook.github.io/react/docs/events.html
    this.refs.btn.addEventListener('mouseleave', this._onMouseLeaveHandler);

    // เพิ่ม JS timeout
    //
    // ย้ำว่าไปเรียกจากข้างนอก (outside React `world`) นะ
    setTimeout(this._onTimeoutHandler, 10000);

    // Make AJAX request
    fetch('https://api.github.com/users')
      .then(this._onAjaxCallback);
  }

  render() {
    console.log('State in render: ' + JSON.stringify(this.state));

    return (
       <button
         ref={(btn) => this.btn = btn}
         onClick={this._onClickHandler}>
         'Click me'
      </button>
    );
  }

  _onClickHandler() {
    console.log('State before (_onClickHandler): ' + JSON.stringify(this.state));
    this.setState({
      dollars: this.state.dollars + 10
    });
    console.log('State after (_onClickHandler): ' + JSON.stringify(this.state));
  },

  _onMouseLeaveHandler() {
    console.log('State before (mouseleave): ' + JSON.stringify(this.state));
    this.setState({
      dollars: this.state.dollars + 20
    });
    console.log('State after (mouseleave): ' + JSON.stringify(this.state));
  }

  _onTimeoutHandler() {
    console.log('State before (timeout): ' + JSON.stringify(this.state));
    this.setState({
      dollars: this.state.dollars + 30
    });
    console.log('State after (timeout): ' + JSON.stringify(this.state));
  }

  _onAjaxCallback(err, res) {
    if (err) {
      console.log('Error in AJAX call: ' + JSON.stringify(err));
      return;
    }

    console.log('State before (AJAX call): ' + JSON.stringify(this.state));
    this.setState({
      dollars: this.state.dollars + 40
    });
    console.log('State after (AJAX call): ' + JSON.stringify(this.state));
  }
};

// Render to DOM
ReactDOM.render(
  <TestComponent />,
  document.getElementById('app')
);
```

### เป็นไปได้หรอ?

เราอาจจะเคยเรียก setState ด้วย parameter เพียงตัวเดียว แต่จริงๆ แล้ว signature ของ method มัน support 2 ตัวนะ ซึ่งเจ้าตัวหลังเนี่ยสามารถส่งเป็น callback function ไปได้ แล้วมันจะถูก execute หลังจาก state ถูก update เสมอ (ไม่ว่ามันจะอยู่ในหรือนอก context ของ React)

#### ตัวอย่างอาจจะเป็นอย่างนี้:

```javascript
_onClickHandler: function _onClickHandler() {
   console.log('State before (_onClickHandler): ' + JSON.stringify(this.state));
   this.setState({
   dollars: this.state.dollars + 10
   }, () => {
   console.log('Here state will always be updated to latest version!');
   console.log('State after (_onClickHandler): ' + JSON.stringify(this.state));
   });
}
```

#### เพิ่มเติม

เพื่อให้มันทำงานได้ถูก setState method ก็เลยเป็น synchronous เสมอ
และมันเป็นแค่ function ที่ไปเรียกอะไรซักอย่างมาจากข้างหลังนั่นเอง (เช่น enqueueState หรือ enqueueCallback บน updater)

จริงๆ แล้ว setState ที่เอามาจาก React source code คืออันข้างล่างนี้:

```javascript
ReactComponent.prototype.setState = function(partialState, callback) {
  invariant(
    typeof partialState === 'object' ||
    typeof partialState === 'function' ||
    partialState == null,
    'setState(...): takes an object of state variables to update or a ' +
    'function which returns an object of state variables.'
  );
  this.updater.enqueueSetState(this, partialState);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'setState');
  }
};
```

สิ่งที่ sync หรือ async จะส่งผลกับการเรียก setState ใน React application ก็คือ reconciliation algorithm, การทำ VDOM comparisons และการเรียก render ไป update real DOM

## links ที่เกี่ยวข้อง:
- https://medium.com/@wereHamster/beware-react-setstate-is-asynchronous-ce87ef1a9cf3#.jhdhncws3
- https://www.bennadel.com/blog/2893-setstate-state-mutation-operation-may-be-synchronous-in-reactjs.htm
