# Async Nature ของ setState()
สำหรับ Async nature ของ setState()

## สาระสำคัญ:
React batches มีการ update และ flush ใหม่ในทุกๆ frame (perf optimization) 
แต่บางกรณี React ก็ไม่มีการควบคุม batching ดังนั้นการ update จึงเกิดขึ้นแบบ synchronous
เช่น eventListeners, Ajax, setTimeout และ Web APIs ที่คล้ายๆ กัน

### ใจความสำคัญ
setState() ไม่ได้เปลี่ยนแปลง this.state ทันที แต่จะสร้าง pending state transition ไว้แทน เพราะงั้นถ้าเข้าถึง this.state หลังการเรียกใช้ method นี้เลยมันอาจ return ค่าเดิมมาให้ จะบอกว่ามันไม่มีอะไรรับประกันกระบวนการ synchronous ของการเรียกใช้ setState นี้หรอก แถมยังจะไป batch performance gains อีกด้วย

ลองรัน code ข้างล่างนี้ดูสิ แล้วคุณจะสังเกตเห็นว่า:

state ของก่อนและหลังทำเหตุการณ์ต่างๆ (ไม่ว่าจะ addEventListener, setTimeout หรือ AJAX call) จะแตกต่างกัน แล้วพอทำ setState method เสร็จ render ก็จะถูกเรียกใหม่ทันที แต่ทำไมเป็นงั้นล่ะ? จะเห็นว่าตัว React มันไม่ได้เข้าใจและมันไปควบคุม code ที่ไม่ได้อยู่ภายใน library มันเองไม่ได้ ยกตัวอย่างก็เช่น code ส่วนที่เรียก Timeout หรือ AJAX จะ execute นอก context ของ React

อ้าว งั้นทำไม React ถึงได้ update state แบบ synchronous ล่ะ? คำตอบก็คือมันพยายามจะ defensive ตัวเองให้มากที่สุด 
การที่มันไปควบคุมไม่ได้ก็หมายความว่ามันไม่สามารถจะทำ perf optimisations อะไรได้เลย ดังนั้นก็จะดีกว่าถ้า update state on spot และ make sure ว่า code หลังจากนั้นมันได้ข้อมูลที่ล่าสุดมา

```javascript
class TestComponent extends React.Component {
  getInitialState() {
    return {
      dollars: 10
    };
  }

  componentDidMount() {
    // เพิ่ม custom event ผ่าน `addEventListener`
    //
    // event ของ React มีส่วนที่ support `mouseleave` ผ่านทาง `onMouseLeave` prop
    //
    // แต่ว่าเราจะไม่เพิ่ม event แบบ 'React way' เพราะมันจะส่งผลกับวิธีการเปลี่ยนแปลง state
    //
    // check events list ได้ที่นี่ - https://facebook.github.io/react/docs/events.html
    this.refs.btn.addEventListener('mouseleave', this._onMouseLeaveHandler);

    // เพิ่ม JS timeout
    //
    // ย้ำว่าไปเรียกจากข้างนอก (outside React `world`) นะ
    setTimeout(this._onTimeoutHandler, 10000);

    // Make AJAX request
    fetch('https://api.github.com/users')
      .then(this._onAjaxCallback);
  }

  render() {
    console.log('State in render: ' + JSON.stringify(this.state));

    return (
       <button
         ref={(btn) => this.btn = btn}
         onClick={this._onClickHandler}>
         'Click me'
      </button>
    );
  }

  _onClickHandler() {
    console.log('State before (_onClickHandler): ' + JSON.stringify(this.state));
    this.setState({
      dollars: this.state.dollars + 10
    });
    console.log('State after (_onClickHandler): ' + JSON.stringify(this.state));
  },

  _onMouseLeaveHandler() {
    console.log('State before (mouseleave): ' + JSON.stringify(this.state));
    this.setState({
      dollars: this.state.dollars + 20
    });
    console.log('State after (mouseleave): ' + JSON.stringify(this.state));
  }

  _onTimeoutHandler() {
    console.log('State before (timeout): ' + JSON.stringify(this.state));
    this.setState({
      dollars: this.state.dollars + 30
    });
    console.log('State after (timeout): ' + JSON.stringify(this.state));
  }

  _onAjaxCallback(err, res) {
    if (err) {
      console.log('Error in AJAX call: ' + JSON.stringify(err));
      return;
    }

    console.log('State before (AJAX call): ' + JSON.stringify(this.state));
    this.setState({
      dollars: this.state.dollars + 40
    });
    console.log('State after (AJAX call): ' + JSON.stringify(this.state));
  }
};

// Render to DOM
ReactDOM.render(
  <TestComponent />,
  document.getElementById('app')
);
```

### เป็นไปได้หรอ?

เราอาจจะเคยเรียก setState ด้วย parameter เพียงตัวเดียว แต่จริงๆ แล้ว signature ของ method มัน support 2 ตัวนะ ซึ่งเจ้าตัวหลังเนี่ยสามารถส่งเป็น callback function ไปได้ แล้วมันจะถูก execute หลังจาก state ถูก update เสมอ (ไม่ว่ามันจะอยู่ในหรือนอก context ของ React)

#### ตัวอย่างอาจจะเป็นอย่างนี้:

```javascript
_onClickHandler: function _onClickHandler() {
   console.log('State before (_onClickHandler): ' + JSON.stringify(this.state));
   this.setState({
   dollars: this.state.dollars + 10
   }, () => {
   console.log('Here state will always be updated to latest version!');
   console.log('State after (_onClickHandler): ' + JSON.stringify(this.state));
   });
}
```

#### เพิ่มเติม

เพื่อให้มันทำงานได้ถูก setState method ก็เลยเป็น synchronous เสมอ
และมันเป็นแค่ function ที่ไปเรียกอะไรซักอย่างมาจากข้างหลังนั่นเอง (เช่น enqueueState หรือ enqueueCallback บน updater)

จริงๆ แล้ว setState ที่เอามาจาก React source code คืออันข้างล่างนี้:

```javascript
ReactComponent.prototype.setState = function(partialState, callback) {
  invariant(
    typeof partialState === 'object' ||
    typeof partialState === 'function' ||
    partialState == null,
    'setState(...): takes an object of state variables to update or a ' +
    'function which returns an object of state variables.'
  );
  this.updater.enqueueSetState(this, partialState);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'setState');
  }
};
```

สิ่งที่ sync หรือ async จะส่งผลกับการเรียก setState ใน React application ก็คือ reconciliation algorithm, การทำ VDOM comparisons และการเรียก render ไป update real DOM

## links ที่เกี่ยวข้อง:
- https://medium.com/@wereHamster/beware-react-setstate-is-asynchronous-ce87ef1a9cf3#.jhdhncws3
- https://www.bennadel.com/blog/2893-setstate-state-mutation-operation-may-be-synchronous-in-reactjs.htm
