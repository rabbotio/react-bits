# One way data flow

One-way direction data flow ทำให้ไม่ต้องมีหลายๆ state และหันไปจัดการเพียง state เดียวซึ่งปกติจะอยู่ใน store
เพื่อที่จะเป็น one way data flow ได้ Store object ของเราจำเป็นต้องมี logic ที่ทำให้เรารู้ว่า state มีการเปลี่ยนแปลงได้ (subscribe for change):
```javascript
var Store = {
  _handlers: [],
  _flag: '',
  onChange: function (handler) {
    this._handlers.push(handler);
  },
  set: function (value) {
    this._flag = value;
    this._handlers.forEach(handler => handler())
  },
  get: function () {
    return this._flag;
  }
};
```
จากนั้นก็มาจัดการ App component หลักของเรา ทีนี้เราก็จะ re-render มันใหม่ทุกครั้งที่ค่าใน Store มีการเปลี่ยนแปลง:
```javascript
class App extends React.Component {
  constructor(props) {
    super(props);
    Store.onChange(this.forceUpdate.bind(this));
  }

  render() {
    return (
      <div>
        <Switcher
          value={ Store.get() }
          onChange={ Store.set.bind(Store) }/>
      </div>
    );
  }
}
```
สังเกตว่าตอนนี้เราใช้ forceUpdate อยู่ ซึ่งจริงๆ แล้วไม่แนะนำนะ

ปกติแล้วจะใช้ high-order component ทำให้มัน re-rendering ได้ แต่ตัวอย่างนี้เราใช้ forceUpdate เพื่อให้เข้าใจได้ง่ายขึ้น

เพราะอย่างนั้น การเปลี่ยนค่าที่แสดงที่ Switcher จึงทำได้ง่าย โดยที่เราไม่ต้องใช้ internal state เลย:
```javascript
class Switcher extends React.Component {
  constructor(props) {
    super(props);
    this._onButtonClick = e => {
      this.props.onChange(!this.props.value);
    }
  }

  render() {
    return (
      <button onClick={ this._onButtonClick }>
        { this.props.value ? 'lights on' : 'lights off' }
      </button>
    );
  }
}
```
ข้อดีในการใช้ pattern แบบนี้คือ component ของเราจะทำเพียงแค่เอาข้อมูลจาก Store มาแสดงผล
การมอง React component ให้เป็นแค่ส่วน view (renderer) จะทำให้ชีวิตง่ายขึ้น
นั่นคือเราเขียน application แบบ declarative และจัดการกับความยุ่งยากซับซ้อนในทีเดียว

### links ที่เกี่ยวข้อง:
- https://www.startuprocket.com/articles/evolution-toward-one-way-data-flow-a-quick-introduction-to-redux