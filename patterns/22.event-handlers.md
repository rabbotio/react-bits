# Event Handlers
ทำการ Binding event handlers ที่ส่วน constructor

หลายครั้งที่ element ใน component มีการทำ event (dispatching event) ซึ่งเราจัดการ DOM event ใน component นั้นเลย เช่นตัวอย่างข้างล่างนี้ เรามีส่วน click handler แล้วต้องการเรียกใช้ function หรือ method นี้ใน component เดียวกัน:

```javascript
class Switcher extends React.Component {
  render() {
    return (
      <button onClick={ this._handleButtonClick }>
        click me
      </button>
    );
  }
  _handleButtonClick() {
    console.log('Button is clicked');
  }
}
```
ตัวอย่างนี้มันทำงานได้เพราะว่า `_handleButtonClick` มันเป็น function และเราก็ส่ง function ไปเป็น attribute ของ onClick ซึ่งถูกต้องแล้ว

ปัญหาก็คือ เนื่องจากส่วน code มันอยู่นอก scope ทำให้ถ้าเราใช้ this ใน `_handleButtonClick` มันก็จะเกิด error ขึ้น
```javascript
class Switcher extends React.Component {
  constructor(props) {
    super(props);
    this.state = { name: 'React in patterns' };
  }
  render() {
    return (
      <button onClick={ this._handleButtonClick }>
        click me
      </button>
    );
  }
  _handleButtonClick() {
    console.log(`Button is clicked inside ${ this.state.name }`);
    // จะเกิด error ตรงนี้
    // Uncaught TypeError: Cannot read property 'state' of null
  }
}
```

ปกติเราก็จะทำการ binding แบบนี้:
```javascript
<button onClick={ this._handleButtonClick.bind(this) }>
  click me
</button>
```
อย่างไรก็ตาม นั่นหมายความว่า function bind นี้จะถูกเรียกซ้ำๆ เพราะเราอาจ render ปุ่มนี้หลายครั้ง ทางที่ดีกว่าก็คือไปทำการ binding ในส่วน constructor ของ component แทน:
```javascript
class Switcher extends React.Component {
  constructor(props) {
    super(props);
    this.state = { name: 'React in patterns' };
    this._buttonClick = this._handleButtonClick.bind(this);
  }
  render() {
    return (
      <button onClick={ this._buttonClick }>
        click me
      </button>
    );
  }
  _handleButtonClick() {
    console.log(`Button is clicked inside ${ this.state.name }`);
  }
}
```

อีกวิธีนึงก็คือเขียน onClick โดยใช้ arrow function มันจะทำการ binding function กับ `this` ให้เอง

Facebook เองก็แนะนำให้ใช้เทคนิคเหมือนๆ กันนี้กับ function ที่ต้องใช้ context ของ component เดียวกัน การ binding ในส่วน constructor แบบนี้อาจจะเป็นประโยชน์ด้วย ถ้าเรามีการส่ง callbacks ลงไปใน component เรื่อยๆ
