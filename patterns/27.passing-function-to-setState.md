# Passing a function to setState
เวลาเรา setState (ซึ่งจริงๆ แล้วมันเป็น asynchronous)
React จะ batch การเปลี่ยนแปลงค่าของ state เอาไว้เพื่อความเร็ว ดังนั้นค่าของ state ก็อาจไม่ได้เปลี่ยนแปลงทันทีหลังจาก setState ถูกเรียก

นั่นแปลว่าเราไม่ควรคิดว่าค่าของ state ที่อ่านได้หลังจากเรียก setState ทันทีนั้นจะถูกต้อง เพราะว่าเราก็ไม่รู้ว่า state มันจะเปลี่ยนไปเป็นอะไร
ดังนั้นวิธีแก้ก็คือ เราจะส่ง function ที่มีค่า state ก่อนหน้าเป็น argument ไปให้ setState ด้วย ก็จะหลีกเลี่ยงปัญหาที่ผู้ใช้อ่านได้ค่า state เก่าได้

#### ปัญหา
```javascript
// assuming this.state.count === 0
this.setState({count: this.state.count + 1});
this.setState({count: this.state.count + 1});
this.setState({count: this.state.count + 1});
// this.state.count === 1, not 3
```
#### ทางแก้
```javascript
this.setState((prevState, props) => ({
  count: prevState.count + props.increment
}));
```

#### ความแตกต่าง
```javascript
// Passing object
this.setState({ expanded: !this.state.expanded });

// Passing function
this.setState(prevState => ({ expanded: !prevState.expanded }));
```

### links ที่เกี่ยวข้อง:
- [setState() Gate](https://medium.com/javascript-scene/setstate-gate-abc10a9b2d82)
- [Do I need to use setState(function) overload in this case?](http://stackoverflow.com/questions/43428456/do-i-need-to-use-setstatefunction-overload-in-this-case/43440790#43440790)
- [Functional setState is the future of React](https://medium.freecodecamp.com/functional-setstate-is-the-future-of-react-374f30401b6b)
