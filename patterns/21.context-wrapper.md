# Context Wrapper
อีกอย่างที่ดีและควรทำก็คือไม่ปล่อยให้ context เป็นแค่ plain object ธรรมดาๆ แต่ควรสร้าง interface ในการเก็บหรือเรียกใช้ข้อมูลให้มันด้วย ตัวอย่างเช่น

```javascript
// dependencies.js
export default {
  data: {},
  get(key) {
    return this.data[key];
  },
  register(key, value) {
    this.data[key] = value;
  }
}
```
ทีนี้กลับไปที่ตัวอย่างของเรา ก็จะได้ App component หน้าตาแบบนี้:
```javascript
import dependencies from './dependencies';
dependencies.register('title', 'React in patterns');

class App extends React.Component {
  getChildContext() {
    return dependencies;
  }
  render() {
    return <Header />;
  }
}

App.childContextTypes = {
  data: PropTypes.object,
  get: PropTypes.func,
  register: PropTypes.func
};
```
และ Title component จะเรียกใช้ข้อมูลผ่าน context แบบนี้:
```javascript
// Title.jsx
export default class Title extends React.Component {
  render() {
    return <h1>{ this.context.get('title') }</h1>
  }
}
Title.contextTypes = {
  data: PropTypes.object,
  get: PropTypes.func,
  register: PropTypes.func
};
```
จริงๆ เราไม่ต้องกำหนด contextTypes ให้มันทุกครั้งที่เราจะใช้ context ก็ได้ โดยอาจจะไปบอกไว้ใน higher-order component แทน หรือยิ่งกว่านั้นเราอาจจะเขียน function นึงขึ้นมา (ในที่นี้คือ wire) เพื่อบอกว่า component ไหนมี contextType อะไรบ้างเลยก็ได้
ตัวอย่างเช่น แทนที่จะเข้าถึง context ตรงๆ ด้วยคำสั่ง this.context.get('title') ก็ให้ higher-order component ไปเอาค่านั้นมาแล้วส่งเป็น props ไปให้ component ของเราแทน แบบนี้
```javascript
// Title.jsx
import wire from './wire';

function Title(props) {
  return <h1>{ props.title }</h1>;
}

export default wire(Title, ['title'], function resolve(title) {
  return { title };
});
```
Function wire นี้จะรับ parameter ตัวแรกเป็น React component ตัวที่สองเป็น array ของ dependency ที่จะใช้ (เป็น dependency ที่ทำการ register ไว้แล้วนะ) และตัวสุดท้ายเป็น function ซึ่งในที่นี้เรียกว่า mapper
เจ้า function wire นี้จะรับสิ่งที่เก็บอยู่ใน context (หรือเรียกว่า raw data) มา แล้ว return object ที่เป็น props สำหรับ component ของเราออกไป ซึ่งก็คือ component Title ในตัวอย่างนี้จะเห็นว่าเราส่งค่าที่อ่านมาได้ ซึ่งก็คือตัวแปร string title ไปเลย แต่ app ที่จะนำไปใช้งานจริงๆ นั้นจะมีข้อมูลที่เก็บใน store เยอะมาก รวมไปถึงค่าที่ config ต่างๆ และอย่างอื่นอีก ดังนั้นก็จะดีกว่าถ้าเราเลือกส่งเฉพาะค่าที่เราต้องการใช้จริงๆ ไปให้ component

หน้าตาของ function wire ก็จะเป็นแบบนี้:
```javascript
export default function wire(Component, dependencies, mapper) {
  class Inject extends React.Component {
    render() {
      var resolved = dependencies.map(this.context.get.bind(this.context));
      var props = mapper(...resolved);

      return React.createElement(Component, props);
    }
  }
  Inject.contextTypes = {
    data: PropTypes.object,
    get: PropTypes.func,
    register: PropTypes.func
  };
  return Inject;
};
```
การ Inject ก็คือ higher-order component ที่มีการเข้าถึง context และอ่านค่า dependency ทั้งหมดที่อยู่ใน array มา 
ส่วน mapper ก็คือ function ที่เอา dependency พวกนั้ันมาแปลงให้เป็น props ของ component นั่นเอง

#### แบบไม่ใช้ context (Non-context alternative)
ก็จะใช้ singleton ในการ register/fetch dependency ทั้งหมดแทน
```javascript
// di.jsx
var dependencies = {};

export function register(key, dependency) {
  dependencies[key] = dependency;
}

export function fetch(key) {
  if (dependencies[key]) return dependencies[key];
  throw new Error(`"${ key } is not registered as dependency.`);
}

export function wire(Component, deps, mapper) {
  return class Injector extends React.Component {
    constructor(props) {
      super(props);
      this._resolvedDependencies = mapper(...deps.map(fetch));
    }
    render() {
      return (
        <Component
          {...this.state}
          {...this.props}
          {...this._resolvedDependencies}
        />
      );
    }
  };
}
```

เราจะเก็บ dependency ทั้งหมดเอาไว้ในตัวแปร dependencies ที่เป็น global ของ module นี้ (ไม่ใช่ระดับ application นะ)

แล้วทำการ export function ออกไป 2 function คือ register สำหรับเพิ่ม dependency และ fetch สำหรับอ่าน dependency

ซึ่งมันจะคล้ายๆ กับการเขียน setter กับ getter ใน JavaScript object

ทีนี้เจ้า function wire จะรับ React component เข้าไป และ return เป็น higher-order component

ในส่วน constructor ก็จะไป fetch dependency มา พอตอน render ก็ส่ง dependency นั้นไปเป็น props ให้กับ component

เราจะยึด pattern เหมือนๆ กัน ก็คือบอกว่าต้องการใช้ dependency อะไร แล้วให้ function mapper เอาเฉพาะ dependency นั้นมาเป็น props

การใช้ di.jsx นี้ทำให้เราสามารถ register dependency จาก entry point ของ application ได้ (ในที่นี้คือ app.jsx) และจะเรียกใช้ dependency นั้นเมื่อไหร่ก็ได้ (ในที่นี้คือเรียกใช้ที่ Title.jsx)

```javascript
// app.jsx
import Header from './Header.jsx';
import { register } from './di.jsx';

register('my-awesome-title', 'React in patterns');

class App extends React.Component {
  render() {
    return <Header />;
  }
}
```
```javascript
// Header.jsx
import Title from './Title.jsx';

export default function Header() {
  return (
    <header>
      <Title />
    </header>
  );
}
```
```javascript
// Title.jsx
import { wire } from './di.jsx';

var Title = function(props) {
  return <h1>{ props.title }</h1>;
};

export default wire(Title, ['my-awesome-title'], title => ({ title }));
```
ถ้าเราดูที่ไฟล์ `Title.jsx` จะเห็นว่าส่วน component จริงๆ กับส่วน wire นี้อาจจะอยู่คนละไฟล์กันก็ได้ ซึ่งจะทำให้สามารถเขียน unit test ได้ง่ายขึ้นด้วย
