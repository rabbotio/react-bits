# Context Wrapper
อีกแนวทางที่ดีก็คือการทำให้ context ไม่เป็นแค่ plain object ธรรมดาๆ แต่สร้าง interface ในการเก็บหรือเรียกใช้ข้อมูลให้มันด้วย ตัวอย่างเช่น

```javascript
// dependencies.js
export default {
  data: {},
  get(key) {
    return this.data[key];
  },
  register(key, value) {
    this.data[key] = value;
  }
}
```
ทีนี้กลับไปที่ตัวอย่างของเรา หน้าตาของ App component ก็จะเป็นแบบนี้:
```javascript
import dependencies from './dependencies';
dependencies.register('title', 'React in patterns');

class App extends React.Component {
  getChildContext() {
    return dependencies;
  }
  render() {
    return <Header />;
  }
}

App.childContextTypes = {
  data: PropTypes.object,
  get: PropTypes.func,
  register: PropTypes.func
};
```
และ Title component จะเรียกใช้ข้อมูลผ่าน context แบบนี้:
```javascript
// Title.jsx
export default class Title extends React.Component {
  render() {
    return <h1>{ this.context.get('title') }</h1>
  }
}
Title.contextTypes = {
  data: PropTypes.object,
  get: PropTypes.func,
  register: PropTypes.func
};
```
จริงๆ เราไม่ต้องกำหนด contextTypes ให้มันทุกครั้งที่เราจะใช้ context ก็ได้ โดยอาจจะไปบอกไว้ใน higher-order component แทน หรือยิ่งกว่านั้นเราอาจจะเขียน function นึงขึ้นมา (ในที่นี้คือ wire) เพื่อบอกว่า component ไหนมี contextType อะไรบ้างเลยก็ได้
ตัวอย่างเช่น แทนที่จะเข้าถึง context ตรงๆ ด้วยคำสั่ง this.context.get('title') ก็ให้ higher-order component ไปเอาค่านั้นมาแล้วส่งเป็น prop ไปให้ component ของเราแทน แบบนี้
```javascript
// Title.jsx
import wire from './wire';

function Title(props) {
  return <h1>{ props.title }</h1>;
}

export default wire(Title, ['title'], function resolve(title) {
  return { title };
});
```
Function wire นี้จะรับ parameter ตัวแรกเป็น React component ตัวที่สองเป็น array ของ dependency ที่จะใช้ (เป็น dependency ที่ทำการ register ไว้แล้วนะ) และตัวสุดท้ายเป็น function ซึ่งในที่นี้เรียกว่า mapper
เจ้า function wire นี้จะรับสิ่งที่เก็บอยู่ใน context (หรือเรียกว่า raw data) มา แล้ว return object ที่เป็น prop สำหรับ component ของเราออกไป ซึ่งก็คือ component Title ในตัวอย่างนี้จะเห็นว่าเราส่งค่าที่อ่านมาได้ทั้งหมดไปเลย (ก็คือตัวแปร string title) แต่ app ที่จะนำไปใช้งานจริงๆ นั้นจะมีข้อมูลที่เก็บใน store เยอะมาก รวมไปถึงค่าที่ config ต่างๆ และอย่างอื่นอีก ดังนั้นก็จะดีกว่าถ้าเราส่งเฉพาะค่าที่เราต้องการใช้จริงๆ ไปให้ component

หน้าตาของ function wire ก็จะเป็นแบบนี้:
```javascript
export default function wire(Component, dependencies, mapper) {
  class Inject extends React.Component {
    render() {
      var resolved = dependencies.map(this.context.get.bind(this.context));
      var props = mapper(...resolved);

      return React.createElement(Component, props);
    }
  }
  Inject.contextTypes = {
    data: PropTypes.object,
    get: PropTypes.func,
    register: PropTypes.func
  };
  return Inject;
};
```
การ Inject ก็คือ higher-order component ที่มีการเข้าถึง context และอ่าน item ทั้งหมดที่อยู่ใน array
Inject is a higher-order component that gets access to the context and retrieves all the items listed under dependencies array.
The mapper is a function receiving the context data and transforms it to props for our component.

#### Non-context alternative
Use a singleton to register/fetch all dependencies
```javascript
var dependencies = {};

export function register(key, dependency) {
  dependencies[key] = dependency;
}

export function fetch(key) {
  if (dependencies[key]) return dependencies[key];
  throw new Error(`"${ key } is not registered as dependency.`);
}

export function wire(Component, deps, mapper) {
  return class Injector extends React.Component {
    constructor(props) {
      super(props);
      this._resolvedDependencies = mapper(...deps.map(fetch));
    }
    render() {
      return (
        <Component
          {...this.state}
          {...this.props}
          {...this._resolvedDependencies}
        />
      );
    }
  };
}
```

We'll store the dependencies in dependencies global variable (it's global for our module, not at an application level).

We then export two functions register and fetch that write and read entries.

It looks a little bit like implementing setter and getter against a simple JavaScript object.

Then we have the wire function that accepts our React component and returns a higher-order component.

In the constructor of that component we are resolving the dependencies and later while rendering the original component we pass them as props.

We follow the same pattern where we describe what we need (deps argument) and extract the needed props with a mapper function.

Having the di.jsx helper we are again able to register our dependencies at the entry point of our application (app.jsx) and inject them wherever (Title.jsx) we need.

```javascript
// app.jsx
import Header from './Header.jsx';
import { register } from './di.jsx';

register('my-awesome-title', 'React in patterns');

class App extends React.Component {
  render() {
    return <Header />;
  }
}
```
```javascript
// Header.jsx
import Title from './Title.jsx';

export default function Header() {
  return (
    <header>
      <Title />
    </header>
  );
}
```
```javascript
// Title.jsx
import { wire } from './di.jsx';

var Title = function(props) {
  return <h1>{ props.title }</h1>;
};

export default wire(Title, ['my-awesome-title'], title => ({ title }));
```
If we look at the `Title.jsx` file we'll see that the actual component and the wiring may live in different files.
That way the component and the mapper function become easily unit testable.
