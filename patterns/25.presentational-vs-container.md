# Presentational and Container components

#### ปัญหา
ส่วนของข้อมูลและลอจิกปนกัน
```javascript
class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {time: this.props.time};
    this._update = this._updateTime.bind(this);
  }

  render() {
    var time = this._formatTime(this.state.time);
    return (
      <h1>{ time.hours } : { time.minutes } : { time.seconds }</h1>
    );
  }

  componentDidMount() {
    this._interval = setInterval(this._update, 1000);
  }

  componentWillUnmount() {
    clearInterval(this._interval);
  }

  _formatTime(time) {
    var [ hours, minutes, seconds ] = [
      time.getHours(),
      time.getMinutes(),
      time.getSeconds()
    ].map(num => num < 10 ? '0' + num : num);

    return {hours, minutes, seconds};
  }

  _updateTime() {
    this.setState({time: new Date(this.state.time.getTime() + 1000)});
  }
}

ReactDOM.render(<Clock time={ new Date() }/>, ...);
```
#### ทางแก้

แบ่ง component ออกเป็น 2 ส่วน คือ container กับ presentation

#### Container Component
Container จะรู้เกี่ยวกับข้อมูลว่ามันมีรูปร่างยังไง หรือมันมาจากไหน รวมถึงรู้ว่าแต่ละส่วนทำงานได้ยังไง เรียกอีกอย่างก็คือเป็นส่วน business logic โดยที่มันจะจัดการกับข้อมูลที่รับมา ทำให้ presentational component เอาข้อมูลนั้นไปใช้งานได้ง่ายๆ 
เรามักจะใช้ higher-order component สร้าง container และส่วน render method ของ container ก็จะมีแค่ presentational component เท่านั้น

```javascript
// Clock/index.js

export default class ClockContainer extends React.Component {
  constructor(props) {
    super(props);
    this.state = {time: props.time};
    this._update = this._updateTime.bind(this);
  }

  render() {
    return <Clock { ...this._extract(this.state.time) }/>;
  }

  componentDidMount() {
    this._interval = setInterval(this._update, 1000);
  }

  componentWillUnmount() {
    clearInterval(this._interval);
  }

  _extract(time) {
    return {
      hours: time.getHours(),
      minutes: time.getMinutes(),
      seconds: time.getSeconds()
    };
  }

  _updateTime() {
    this.setState({time: new Date(this.state.time.getTime() + 1000)});
  }
};
```
#### Presentational component
ส่วน presentational component นี้เป็นเหมือนเวทีคอนเสิร์ตที่แสดงทุกอย่าง มันจะมีส่วน markup เสริมที่ทำให้หน้าเพจดูสวยขึ้น component ประเภทนี้จะไม่มีส่วนที่ต้องยึดติดกับอย่างอื่น ไม่มี dependency
และมักจะถูกเขียนแบบ stateless functional component ก็คือไม่มี internal state นั่นเอง

```javascript
// Clock/Clock.jsx
export default function Clock(props) {
  var [ hours, minutes, seconds ] = [
    props.hours,
    props.minutes,
    props.seconds
  ].map(num => num < 10 ? '0' + num : num);

  return <h1>{ hours } : { minutes } : { seconds }</h1>;
};
```
ข้อดีอีกอย่างของ container ก็คือมันจะห่อหุ้มส่วนลอจิกไว้ และอาจเลือกส่งข้อมูลที่ไม่เหมือนกันไปให้ renderer แต่ละส่วนได้
ส่วนมากแล้วไฟล์ที่ export container จะไม่ส่งออกไปเป็น class ตรงๆ แต่จะส่งไปเป็น function
ตัวอย่างเช่น แทนที่จะ export แบบนี้

```javascript
import Clock from './Clock.jsx';
export default class ClockContainer extends React.Component {
  render() {
    return <Clock />;
  }
}
```
เราอาจ export function ที่รับ presentational component ไปแทน:
```javascript
export default function (Component) {
  return class Container extends React.Component {
    render() {
      return <Component />;
    }
  }
}
```
การใช้เทคนิคนี้จะทำให้ container ของเราสามารถ render ผลลัพธ์ออกไปได้ยืดหยุ่นมากขึ้น แล้วถ้าเราต้องการเปลี่ยนการแสดงผลจากนาฬิกาแบบ digital ไปเป็น analog เราก็สามารถทำได้ง่ายขึ้นเช่นกัน

### links ที่เกี่ยวข้อง:
 - https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.mbglcakmp
 - https://github.com/krasimir/react-in-patterns/tree/master/patterns/presentational-and-container
 - https://medium.com/@learnreact/container-components-c0e67432e005